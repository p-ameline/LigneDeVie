package com.ldv.shared.graph;

import java.util.Collections;
import java.util.Comparator;
import java.util.ListIterator;
import java.util.Vector;
import java.util.Iterator;

public class LdvModelTree
{
	protected String               _sTREE_ID ;
	protected Vector<LdvModelNode> _aNodes ;
	
	public LdvModelTree()
	{
		_aNodes = new Vector<LdvModelNode>() ;
		init() ; 
	}
	
	public LdvModelTree(String sTreeId)
	{
		_sTREE_ID      = sTreeId ;
		_aNodes = new Vector<LdvModelNode>() ;
	}
	
	public void sortByLocalisation()
	{
		Comparator<LdvModelNode> orderLocalisation = new Comparator<LdvModelNode>()
		{
			public int compare(LdvModelNode node1, LdvModelNode node2)
			{ return node1.getLine() - node2.getLine() ; }
		};
		
		Collections.sort(_aNodes, orderLocalisation) ;
	}
	
	void init()
	{
		_sTREE_ID = "" ;
	}
	
	/**
	 * Add a new node (at the end of the tree) at a given column 
	 * 
	 * @param node node to be added
	 * @param iColNumber column the new node has to be added to
	 * 
	 **/
	public void addNode(final LdvModelNode node, final int iColNumber)
	{
		if ((null == node) || (iColNumber < 0))
			return ;
		
		LdvModelNode newNode = new LdvModelNode(node) ;
		newNode.setCol(iColNumber) ;
		
		if (_aNodes.isEmpty())
			newNode.setLine(0) ;
		else
		{
			int iLastLine = _aNodes.lastElement().getLine() ;
			newNode.setLine(iLastLine + 1) ;
		}
		
		_aNodes.add(newNode) ;
	}
	
	/**
	 * Find the node located at a given line and column 
	 * 
	 * @param iLine line
	 * @param iCol column
	 * @return the node if found, <code>null</code> if not
	 * 
	 **/
	public LdvModelNode findNode(final int iLine, final int iCol)
	{
		if (_aNodes.isEmpty())
			return null ;
		
		Iterator<LdvModelNode> nodeIter = _aNodes.iterator() ;
		while (nodeIter.hasNext())
		{
			LdvModelNode node = nodeIter.next() ;
			if ((node.getLine() == iLine) && (node.getCol() == iCol))
				return node ;
		}
		
		return null ;
	}
	
	/**
	 * Find the node located at a given line and column and returns its index 
	 * 
	 * @param iLine node's line
	 * @param iCol node's column
	 * @return index of the node if found, <code>-1</code> if not
	 * 
	 **/
	public int findNodeIndex(final int iLine, final int iCol)
	{
		if (_aNodes.isEmpty())
			return -1 ;
		
		ListIterator<LdvModelNode> nodeIter = _aNodes.listIterator() ;
		while (nodeIter.hasNext())
		{
			LdvModelNode node = nodeIter.next() ;
			if ((node.getLine() == iLine) && (node.getCol() == iCol))
				return nodeIter.previousIndex() ;
		}
		
		return -1 ;
	}
		
	/**
	 * Find the first son node of the node located at a given index and returns its index 
	 * 
	 * @param iFatherIndex father node's index
	 * @return index of the node if found, <code>-1</code> if not
	 * 
	 **/
	public int findFirstSonIndex(final int iFatherIndex) throws IndexOutOfBoundsException
	{
		if (_aNodes.isEmpty())
			return -1 ;
		
		if ((iFatherIndex < 0) || (iFatherIndex >= _aNodes.size()))
			throw new IndexOutOfBoundsException() ;
		
		ListIterator<LdvModelNode> nodeIter = _aNodes.listIterator(iFatherIndex) ;
		LdvModelNode fatherNode = nodeIter.next() ;
		int iFatherCol = fatherNode.getCol() ;
		
		if (nodeIter.hasNext())
		{
			LdvModelNode node = nodeIter.next() ;
			if (node.getCol() > iFatherCol)
				return nodeIter.previousIndex() ;
		}
		
		return -1 ;
	}
	
	/**
	 * Find the first brother node of the node located at a given index and returns its index 
	 * 
	 * @param iReferenceBrotherIndex reference node's index
	 * @return index of the node if found, <code>-1</code> if not
	 * 
	 **/
	public int findFirstBrotherIndex(final int iReferenceBrotherIndex) throws IndexOutOfBoundsException
	{
		if (_aNodes.isEmpty())
			return -1 ;
		
		if ((iReferenceBrotherIndex < 0) || (iReferenceBrotherIndex >= _aNodes.size()))
			throw new IndexOutOfBoundsException() ;
		
		ListIterator<LdvModelNode> nodeIter = _aNodes.listIterator(iReferenceBrotherIndex) ;
		LdvModelNode refBrotherNode = nodeIter.next() ;
		int iRefBrotherCol = refBrotherNode.getCol() ;
		
		while (nodeIter.hasNext())
		{
			LdvModelNode node = nodeIter.next() ;
			if (node.getCol() == iRefBrotherCol)
				return nodeIter.previousIndex() ;
			
			// This test means that we met a father or grandfather
			//
			if (node.getCol() < iRefBrotherCol)
				return -1 ;
		}
		
		return -1 ;
	}
	
	/**
	 * Is tree empty ? 
	 * 
	 * @return <code>true</code> if empty, <code>false</code> if not
	 * 
	 **/
	public boolean isEmpty()
	{
		return _aNodes.isEmpty() ;
	}

	public String getTreeID()
  {
  	return _sTREE_ID ;
  }
	public void setTreeID(String sID)
  {
		_sTREE_ID = sID ;
  }

	public Vector<LdvModelNode> getNodes()
  {
  	return _aNodes ;
  }
	public void setNodes(Vector<LdvModelNode> aNodes)
  {
  	_aNodes = aNodes ;
  }

	/**
	 * Returns the node located at a given index 
	 * 
	 * @param iIndex index (from <code>0</code> to <code>size-1</code>)
	 * @return the corresponding LdvModelNode if found, <code>null</code> if not
	 * 
	 **/
	public LdvModelNode getNodeAtIndex(int iIndex) throws IndexOutOfBoundsException
	{
		if ((iIndex < 0) || (iIndex >= _aNodes.size()))
			throw new IndexOutOfBoundsException() ;
		
		return _aNodes.get(iIndex) ;
	}
}
