package com.ldv.server.model;

import java.io.*;
import java.util.zip.*;
import java.util.Iterator;
import java.util.Vector;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.BufferedBlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.paddings.BlockCipherPadding;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.paddings.ZeroBytePadding;
import org.bouncycastle.crypto.params.KeyParameter;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import com.ldv.client.util.FieldVerifier;
import com.ldv.shared.graph.LdvGraphConfig;
import com.ldv.shared.graph.LdvGraphTools;
import com.ldv.shared.graph.LdvModelNode;
import com.ldv.shared.graph.LdvModelTree;
import com.ldv.shared.model.DocumentLabel;
import com.ldv.shared.model.LdvTime;

public class LdvXmlGraph
{	
	protected int              _iServerType ;
	
	protected Document               _aTechnicalData ;
	protected Vector<LdvXmlDocument> _aTrees ;
	protected Document               _aLinks ;
	protected Document               _aRights ;
	
	protected String           _sPersonId ;
	protected String           _sMaxTreeId ;
	
	public static String LINKS_ROOT_LABEL      = "links" ;
	public static String LINK_LABEL            = "link" ;
	
	public static String LINK_QUALIFIED_ATTR   = "qualified" ;
	public static String LINK_LINK_ATTR        = "semantic" ;
	public static String LINK_QUALIFIER_ATTR   = "qualifier" ;
	public static String LINK_TRANSACTION_ATTR = "transaction" ;
	
	public static String RIGHTS_ROOT_LABEL     = "rights" ;
	public static String RIGHT_LABEL           = "right" ;
	
	public static String RIGHT_DOCUMENT_ATTR   = "document" ;
	public static String RIGHT_NODE_ATTR       = "node" ;
	public static String RIGHT_ROSE_ATTR       = "rose" ;
	public static String RIGHT_VALUE_ATTR      = "value" ;
	
	public LdvXmlGraph(int iServerType, String sPersonId)
	{
		_iServerType = iServerType ;
		
		_aTrees = new Vector<LdvXmlDocument>() ;
		
		_sPersonId   = sPersonId ;
		_sMaxTreeId  = LdvGraphConfig.UNKNOWN_ROOTDOC[_iServerType] ;
	}
	
	/**
	 * Create and initialize the document that hosts links 
	 * 
	 **/
	public void createNewLinksDocument()
	{
		// Get factory instance
		//
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance() ;
		DocumentBuilder builder ;
    try
    {
	    builder = factory.newDocumentBuilder() ;
    } 
    catch (ParserConfigurationException e)
    {
	    // TODO Auto-generated catch block
	    e.printStackTrace();
	    return ;
    }
    
    // Create a document
    //
    DOMImplementation impl = builder.getDOMImplementation();
		
    _aLinks = impl.createDocument(null, null, null) ;
    
    // Create Root
    //
    Element eRoot = _aLinks.createElement(LINKS_ROOT_LABEL) ;
    _aLinks.appendChild(eRoot) ;
	}
	
	/**
	 * Add a new link 
	 * 
	 **/
	public void addNewLink(String sQualified, String sLink, String sQualifier, String sTransaction)
	{
		Element linksRootElement = _aLinks.getDocumentElement() ;
		
		Element eNewLink = _aLinks.createElement(LINK_LABEL) ;
		eNewLink.setAttribute(LINK_QUALIFIED_ATTR,   sQualified) ;
		eNewLink.setAttribute(LINK_LINK_ATTR,        sLink) ;
		eNewLink.setAttribute(LINK_QUALIFIER_ATTR,   sQualifier) ;
		eNewLink.setAttribute(LINK_TRANSACTION_ATTR, sTransaction) ;
		
		linksRootElement.appendChild(eNewLink) ;
	}
	
	/**
	 * Create and initialize the document that hosts rights 
	 * 
	 **/
	public void createNewRightsDocument()
	{
		// Get factory instance
		//
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance() ;
		DocumentBuilder builder ;
    try
    {
	    builder = factory.newDocumentBuilder() ;
    } 
    catch (ParserConfigurationException e)
    {
	    // TODO Auto-generated catch block
	    e.printStackTrace();
	    return ;
    }
    
    // Create a document
    //
    DOMImplementation impl = builder.getDOMImplementation();
		
    _aRights = impl.createDocument(null, null, null) ;
    
    // Create Root
    //
    Element eRoot = _aRights.createElement(RIGHTS_ROOT_LABEL) ;
    _aRights.appendChild(eRoot) ;
	}
	
	/**
	 * Add a new right 
	 * 
	 **/
	public void addNewRight(String sDocument, String sNode, String sRose, String sRights)
	{
		Element rightsRootElement = _aRights.getDocumentElement() ;
		
		Element eNewRight = _aRights.createElement(RIGHT_LABEL) ;
		
		eNewRight.setAttribute(RIGHT_DOCUMENT_ATTR, sDocument) ;
		eNewRight.setAttribute(RIGHT_NODE_ATTR,     sNode) ;
		eNewRight.setAttribute(RIGHT_ROSE_ATTR,     sRose) ;
		eNewRight.setAttribute(RIGHT_VALUE_ATTR,    sRights) ;
		
		rightsRootElement.appendChild(eNewRight) ;
	}
	
	/**
	 * Create and initialize the set of documents that represents a project
	 * 
	 **/
	public boolean addNewProject(String sProjectLexique, String sRootDocId)
	{
		if ((null == sProjectLexique) || sProjectLexique.equals(""))
			return false ;
		
		LdvTime timeNow = new LdvTime(0) ;
		timeNow.takeTime() ;
		
		//
		// Create project's root document
		//
		
		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return false ;
		String sRootLabelTreeId = _sMaxTreeId ;
		
		// Create root document's label 
		//
		DocumentLabel rootLabelDoc = new DocumentLabel(sRootLabelTreeId, LdvGraphConfig.SYSTEM_USER, "ZCS001", "root", sProjectLexique, timeNow) ;
		LdvXmlDocument rootLabel = new LdvXmlDocument(this, rootLabelDoc) ;
		_aTrees.add(rootLabel) ;

		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return false ;
		String sRootDocTreeId = _sMaxTreeId ;
		
		// Create root document's data 
		//
		LdvXmlDocument rootDocument = new LdvXmlDocument(this, sRootDocTreeId, sProjectLexique) ;
		_aTrees.add(rootDocument) ;
		
		// Link label and document
		//
		addNewLink(sRootLabelTreeId, "ZDATA", sRootDocTreeId, "") ;
		
		// Link label and root label
		//
		addNewLink(sRootDocId, "0PROJ", sRootLabelTreeId, "") ;

		// Create project's team document
		//
		String sTeamDocumentId = createProjectTeam(sRootLabelTreeId, timeNow) ;
		
		// Create project's folders library document
		//
		String sFoldersDocumentId = createProjectFoldersLibrary(sRootLabelTreeId, timeNow) ;

		// Create project's concerns library document
		//
		String sConcernsDocumentId = createProjectConcerns(sRootLabelTreeId, timeNow) ;
		
		return true ;
	}
	
	/**
	 * Create a new graph 
	 * 
	 * @param sPersonId Identifier of the person
	 * @return true of all went well
	 * 
	 **/
	public boolean initNewGraph(String sPersonId)
	{
		if ((null == sPersonId) || sPersonId.equals(""))
			return false ;
		
		createNewLinksDocument() ;
		createNewRightsDocument() ;
		
		LdvTime timeNow = new LdvTime(0) ;
		timeNow.takeTime() ;
		
		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return false ;
		String sRootLabelTreeId = _sMaxTreeId ;
		
		// Create root document's label 
		//
		DocumentLabel rootLabelDoc = new DocumentLabel(sRootLabelTreeId, LdvGraphConfig.SYSTEM_USER, "ZCS001", "root", "HHUMA3", timeNow) ;
		LdvXmlDocument rootLabel = new LdvXmlDocument(this, rootLabelDoc) ;
		_aTrees.add(rootLabel) ;

		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return false ;
		String sRootDocTreeId = _sMaxTreeId ;
		
		// Create root document's data 
		//
		LdvXmlDocument rootDocument = new LdvXmlDocument(this, sRootDocTreeId, "HHUMA3") ;
		_aTrees.add(rootDocument) ;
		
		// Link label and document
		//
		addNewLink(sRootLabelTreeId, "ZDATA", sRootDocTreeId, "") ;
		
		// Create Life Project
		//
		addNewProject("0PRVI1", sRootLabelTreeId) ;
		
		// Create Health Project
		//
		addNewProject("0PRSA1", sRootLabelTreeId) ;
		
		// Create Social Project
		//
		addNewProject("0PRSO1", sRootLabelTreeId) ;
		
		// Create Education Project
		//
		addNewProject("0PEDU1", sRootLabelTreeId) ;
		
		// Create Professional Project
		//
		addNewProject("0PRPR1", sRootLabelTreeId) ;
		
		// Create Financial Project
		//
		addNewProject("0PRFI1", sRootLabelTreeId) ;
		
		// Create Asset management Project
		//
		addNewProject("0PRAC1", sRootLabelTreeId) ;
		
    return true ;
	}
	
	/**
	 * Write all files to disk 
	 * 
	 * @param sDirectory Where to write files
	 * @return true of all went well
	 * 
	 **/
	public boolean exportFiles(String sDirectory, String sSecretKey)
	{
		String sLinksFileTitle = sDirectory + _sPersonId + "_links.xml" ;
		LdvXmlDocument.writeDocumentToDisk(_aLinks, sLinksFileTitle) ;
		
		if (false == _aTrees.isEmpty())
		{
			for (Iterator<LdvXmlDocument> itr = _aTrees.iterator() ; itr.hasNext() ; )
			{
				LdvXmlDocument doc = itr.next() ;
				String sDocFileTitle = sDirectory + _sPersonId + "_" + doc.getDocumentId() + ".xml" ;
				LdvXmlDocument.writeDocumentToDisk(doc.getFinalDocument(), sDocFileTitle) ;
			}
		}
		
		zipFiles(sDirectory) ;
	
		cypherZipFileBC(sDirectory, sSecretKey) ;
		decypherZipFileBC(sDirectory, sSecretKey) ;
		
		return true ;
	}
	
	/**
	 * Assemble all files into a single zip 
	 * 
	 * @param sDirectory Where to write files
	 * @return true of all went well
	 * 
	 **/
	public boolean zipFiles(String sDirectory)
	{
		String sLinksFileTitle = sDirectory + _sPersonId + "_links.xml" ;
		LdvXmlDocument.writeDocumentToDisk(_aLinks, sLinksFileTitle) ;
		
		final int BUFFERSIZE = 2048 ;
		
		String sAllFiles = sDirectory + "." ;
		String sZipFile  = sDirectory + _sPersonId + ".zip" ;
		
		try 
		{
			BufferedInputStream origin = null ;
      
      // get the list of files from user directory
      //
      File f = new File(sAllFiles) ;
      String files[] = f.list() ;

      FileOutputStream dest = new FileOutputStream(sZipFile) ;
      ZipOutputStream  out  = new ZipOutputStream(new BufferedOutputStream(dest)) ;
      //out.setMethod(ZipOutputStream.DEFLATED);
      byte data[] = new byte[BUFFERSIZE] ;
      
      for (int i = 0 ; i < files.length ; i++) 
      {
      	// System.out.println("Adding: "+files[i]);
      	
      	String sFileName = sDirectory + files[i] ;
      	FileInputStream fi = new FileInputStream(sFileName) ;
      	
      	// Add file to zip
      	//
      	origin = new BufferedInputStream(fi, BUFFERSIZE) ;
      	ZipEntry entry = new ZipEntry(files[i]) ;
        out.putNextEntry(entry) ;
        int count ;
        while((count = origin.read(data, 0, BUFFERSIZE)) != -1) 
        	out.write(data, 0, count) ;
        
        origin.close() ;
        
        // Delete file
        //
        File fDel = new File(sFileName) ;
        fDel.delete() ;
      }
      out.close() ;
		} catch(Exception e) {
			e.printStackTrace() ;
			return false ;
		}
		
   	return true ;
	}
	
	/**
	 * Encrypt zip file
	 * 
	 * @param sDirectory Where to write files
	 * @param sSecretKey Secret key for symmetrical encryption 
	 * @return true if all went well
	 * 
	 **/
	public boolean cypherZipFile(String sDirectory, String sSecretKey)
	{
		String sZipFile  = sDirectory + _sPersonId + ".zip" ;
		
		try {
			
			// File to cypher
			//
			File f = new File(sZipFile) ;
			byte[] buffer = new byte[(int)f.length()] ;
			DataInputStream in = new DataInputStream(new FileInputStream(f)) ;
			in.readFully(buffer) ;
			in.close() ;

			// Setting Initial Value
			//
			byte[] iv = { (byte) 0xc9, (byte) 0x36, (byte) 0x78, (byte) 0x99,
						  (byte) 0x52, (byte) 0x3e, (byte) 0xea, (byte) 0xf2 };

			IvParameterSpec salt = new IvParameterSpec(iv) ;
			
			// Secret key
			//
			byte[] raw = sSecretKey.getBytes();
			SecretKey skeySpec = new SecretKeySpec(raw, "Blowfish");

			// File encryption
			//
			Cipher c = Cipher.getInstance("Blowfish/CBC/PKCS5Padding", "BC");    
		    c.init(Cipher.ENCRYPT_MODE, skeySpec, salt);
			byte[] buf_crypt = c.doFinal(buffer);

			FileOutputStream envfos = new FileOutputStream("fichier_chiffre");
			envfos.write(buf_crypt);
			envfos.close();

			// Déchiffrement du fichier
			c = Cipher.getInstance("Blowfish/CBC/PKCS5Padding", "BC");    
			c.init(Cipher.DECRYPT_MODE, skeySpec, salt);
			byte[] buf_decrypt = c.doFinal(buf_crypt);

			envfos = new FileOutputStream("fichier_dechiffre");
			envfos.write(buf_decrypt);
			envfos.close();

		} catch (Exception e) {
			e.printStackTrace();
			return false ;
		}
		
		return true ;
	}
	
	/**
	 * Encrypt zip file
	 * 
	 * @param sDirectory Where to write files
	 * @param sSecretKey Secret key for symmetrical encryption 
	 * @return true if all went well
	 * 
	 **/
	public boolean cypherZipFileBC(String sDirectory, String sSecretKey) 
	{
		String sZipFile  = sDirectory + _sPersonId + ".zip" ;
		String sAESFile  = sDirectory + _sPersonId + ".ldv" ;

		boolean bSuccess = cypherFileBC(sZipFile, sAESFile, sSecretKey, true) ; 
		
		if (bSuccess)
		{
			// Delete zip file
      //
      File fDel = new File(sZipFile) ;
      fDel.delete() ;
		}
		
		return bSuccess ;
	}
	
	/**
	 * Encrypt zip file
	 * 
	 * @param sDirectory Where to write files
	 * @param sSecretKey Secret key for symmetrical encryption 
	 * @return true if all went well
	 * 
	 **/
	public boolean decypherZipFileBC(String sDirectory, String sSecretKey) 
	{
		String sZipFile  = sDirectory + _sPersonId + "test.zip" ;
		String sAESFile  = sDirectory + _sPersonId + ".ldv" ;
	
		boolean bSuccess = cypherFileBC(sAESFile, sZipFile, sSecretKey, false) ; 
		
		return bSuccess ;		
	}

	/**
	 * Encrypt zip file
	 * 
	 * @param sDirectory Where to write files
	 * @param sSecretKey Secret key for symmetrical encryption 
	 * @return true if all went well
	 * 
	 **/
	public boolean cypherFileBC(String sInputFile, String sOutputFile, String sSecretKey, boolean forEncryption) 
	{
		if (false == FieldVerifier.isValidFileName(sInputFile))
			return false ;
		if (false == FieldVerifier.isValidFileName(sOutputFile))
			return false ;
		if (false == FieldVerifier.isValidSecretKey(sSecretKey))
			return false ;
		
		// File to cypher or decypher
		//
		File f = new File(sInputFile) ;
		byte[] buffer = new byte[(int)f.length()] ;
		DataInputStream in;
		try
		{
			in = new DataInputStream(new FileInputStream(f));
			try
			{
				in.readFully(buffer) ;
				in.close() ;
			} 
			catch (IOException e1)
			{
				// TODO Auto-generated catch block
				e1.printStackTrace();
				return false ;
			}
		} 
		catch (FileNotFoundException e1)
		{
			// TODO Auto-generated catch block
			e1.printStackTrace();
			return false ;
		}
			
		// Secret key
		//
		byte[] key = sSecretKey.getBytes() ;
		assert key.length == 32; // 32 bytes == 256 bits
		CipherParameters cipherParameters = new KeyParameter(key) ;

		/*
		 * A full list of BlockCiphers can be found at http://www.bouncycastle.org/docs/docs1.6/org/bouncycastle/crypto/BlockCipher.html
		 */
		BlockCipher blockCipher = new AESEngine() ;

		/*
		 * Paddings available (http://www.bouncycastle.org/docs/docs1.6/org/bouncycastle/crypto/paddings/BlockCipherPadding.html):
		 *   - ISO10126d2Padding
		 *   - ISO7816d4Padding
		 *   - PKCS7Padding
		 *   - TBCPadding
		 *   - X923Padding
		 *   - ZeroBytePadding
		 */
		BlockCipherPadding blockCipherPadding = new ZeroBytePadding() ;

		BufferedBlockCipher bufferedBlockCipher = new PaddedBufferedBlockCipher(blockCipher, blockCipherPadding) ;

		byte[] buf_crypt;
		try
		{
			buf_crypt = process(buffer, bufferedBlockCipher, cipherParameters, forEncryption) ;
		} 
		catch (InvalidCipherTextException e1)
		{
			// TODO Auto-generated catch block
			e1.printStackTrace();
			return false ;
		}
			
		FileOutputStream envfos;
		try
		{
			envfos = new FileOutputStream(sOutputFile) ;
			
			try
			{
				envfos.write(buf_crypt) ;
				envfos.close() ;
			} 
			catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
				return false ;
			}
		} 
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
			return false ;
		}
			
		return true ;
	}
	
	public byte[] encrypt(byte[] input, BufferedBlockCipher bufferedBlockCipher, CipherParameters cipherParameters) throws InvalidCipherTextException 
	{
    boolean forEncryption = true ;
    return process(input, bufferedBlockCipher, cipherParameters, forEncryption) ;
	}

	public byte[] decrypt(byte[] input, BufferedBlockCipher bufferedBlockCipher, CipherParameters cipherParameters) throws InvalidCipherTextException 
	{
		boolean forEncryption = false ;
    return process(input, bufferedBlockCipher, cipherParameters, forEncryption) ;
	}

	public byte[] process(byte[] input, BufferedBlockCipher bufferedBlockCipher, CipherParameters cipherParameters, boolean forEncryption) throws InvalidCipherTextException 
	{
    bufferedBlockCipher.init(forEncryption, cipherParameters) ;

    int inputOffset = 0;
    int inputLength = input.length;

    int maximumOutputLength = bufferedBlockCipher.getOutputSize(inputLength);
    byte[] output = new byte[maximumOutputLength];
    int outputOffset = 0;
    int outputLength = 0;

    int bytesProcessed;

    bytesProcessed = bufferedBlockCipher.processBytes(
            input, inputOffset, inputLength,
            output, outputOffset
        );
    outputOffset += bytesProcessed;
    outputLength += bytesProcessed;

    bytesProcessed = bufferedBlockCipher.doFinal(output, outputOffset);
    outputOffset += bytesProcessed;
    outputLength += bytesProcessed;

    if (outputLength == output.length) {
        return output;
    } else {
        byte[] truncatedOutput = new byte[outputLength];
        System.arraycopy(
                output, 0,
                truncatedOutput, 0,
                outputLength
            );
        return truncatedOutput;
    }
	}
	
	/**
	 * Get tree Id for a new tree 
	 * 
	 * @return <code>true</code> if everything went well
	 * 
	 **/
	public boolean getNexTreeId()
	{
		StringBuffer nextId = new StringBuffer(_sMaxTreeId) ;
		
		// First tree
		//
		if (_sMaxTreeId.equals(LdvGraphConfig.UNKNOWN_ROOTDOC[_iServerType]))
		{
			if      (LdvGraphConfig.LOCAL_SERVER == _iServerType) 
				nextId.setCharAt(0, LdvGraphConfig.LOCAL_CHAR) ;
			else if ((LdvGraphConfig.GROUP_SERVER == _iServerType) || (LdvGraphConfig.DIRECT_GROUP_SERVER == _iServerType))
				nextId.setCharAt(0, LdvGraphConfig.GROUP_CHAR) ;
			else if ((LdvGraphConfig.COLLECTIVE_SERVER == _iServerType) || (LdvGraphConfig.DIRECT_COLLECTIVE_SERVER == _iServerType))
				nextId.setCharAt(0, '0') ;
			else
				return false ;
			
			for (int i = 1 ; i < nextId.length() ; i++)
				nextId.setCharAt(i, '0') ;
			
			_sMaxTreeId = nextId.toString() ;
			
			return true ;
		}
		
		try
		{
			String sNewMaxTreeId = LdvGraphTools.getNextId(_sMaxTreeId) ;
			
			if (sNewMaxTreeId.equals(""))
				return false ;
			
			_sMaxTreeId = sNewMaxTreeId ;
			
			return true ;
			
		} catch (NumberFormatException e)
		{
			return false ;
		}
	}
	
	/**
	 * Create a new graphElement 
	 * 
	 * @return <code>true</code> if everything went well
	 * 
	 **/
	public boolean buildRootElements(DOMImplementation impl)
	{
		if ((null == impl) || (null == _sPersonId) || _sPersonId.equals(""))
			return false ;
		
		Document rootDoc = impl.createDocument(null, null, null) ;
		
    // Create Root
    //
    Element e1 = rootDoc.createElement("graphElement");
    rootDoc.appendChild(e1);
		
		return true ;
	}

	/**
	 * Create a team document 
	 * 
	 * @param sProjectDocumentId project's root document Id
	 * @param timeNow creation time
	 * @return team document's Id
	 * 
	 **/
	public String createProjectTeam(String sProjectDocumentId, LdvTime timeNow)
	{
		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return "" ;
		String sLabelTreeId = _sMaxTreeId ;
	
		// Create team document's label 
		//
		DocumentLabel LabelDoc = new DocumentLabel(sLabelTreeId, LdvGraphConfig.SYSTEM_USER, "ZCS001", "team", "LEQUI1", timeNow) ;
		LdvXmlDocument Label = new LdvXmlDocument(this, LabelDoc) ;
		_aTrees.add(Label) ;

		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return "" ;
		String sDocTreeId = _sMaxTreeId ;
	
		// Create team document's data 
		//
		LdvModelTree tree = new LdvModelTree() ;
		tree.addNode(new LdvModelNode("LEQUI1"), 0) ;
		tree.addNode(new LdvModelNode("HMEMB1"), 1) ;
		tree.addNode(new LdvModelNode("£SPID1", _sPersonId), 2) ;
		
  	LdvTime dNoLimit = new LdvTime(0) ;
  	dNoLimit.setNoLimit() ;
  	//
  	// Add an administration mandate for angle 0, radius 0, starting now with no limit
		//
		addAdministrationMandate(tree, 0, 0, timeNow, dNoLimit) ;
		//
  	// Add an access mandate for the same conditions
		//
		addAdministrationMandate(tree, 0, 0, timeNow, dNoLimit) ;
		
		LdvXmlDocument Document = new LdvXmlDocument(this, sDocTreeId, tree) ;
		_aTrees.add(Document) ;
	
		// Link label and document
		//
		addNewLink(sLabelTreeId, "ZDATA", sDocTreeId, "") ;
	
		// Link team label and root label
		//
		addNewLink(sProjectDocumentId, "LEQUI", sLabelTreeId, "") ;
		
		return sLabelTreeId ;
	} 
	
	/**
	 * Create a concerns document 
	 * 
	 * @param sProjectDocumentId project's root document Id
	 * @param timeNow creation time
	 * @return concern document's Id
	 * 
	 **/
	public String createProjectConcerns(String sProjectDocumentId, LdvTime timeNow)
	{
		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return "" ;
		String sLabelTreeId = _sMaxTreeId ;
	
		// Create team document's label 
		//
		DocumentLabel LabelDoc = new DocumentLabel(sLabelTreeId, LdvGraphConfig.SYSTEM_USER, "ZCS001", "team", "ZPOMR1", timeNow) ;
		LdvXmlDocument Label = new LdvXmlDocument(this, LabelDoc) ;
		_aTrees.add(Label) ;

		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return "" ;
		String sDocTreeId = _sMaxTreeId ;
	
		// Create team document's data 
		//
		LdvModelTree tree = new LdvModelTree() ;
		tree.addNode(new LdvModelNode("ZPOMR1"), 0) ;
		tree.addNode(new LdvModelNode("0PRO11"), 1) ;
		tree.addNode(new LdvModelNode("0OBJE1"), 1) ;
		tree.addNode(new LdvModelNode("N00001"), 1) ;
		
		LdvXmlDocument Document = new LdvXmlDocument(this, sDocTreeId, tree) ;
		_aTrees.add(Document) ;
	
		// Link label and document
		//
		addNewLink(sLabelTreeId, "ZDATA", sDocTreeId, "") ;
	
		// Link team label and root label
		//
		addNewLink(sProjectDocumentId, "ZPOMR", sLabelTreeId, "") ;
		
		return sLabelTreeId ;
	} 
	
	/**
	 * Adding an administration mandate in a team document tree
	 * 
	 * @param tree <code>LdvModelTree</code> to add information to
	 * @param iAngle angle in the rose 
	 * @param iRadius radius in the rose
	 * @param dStartDate mandate starting date
	 * @param dEndDate mandate ending date
	 * @return void
	 * 
	 **/
	public void addAdministrationMandate(LdvModelTree tree, int iAngle, int iRadius, LdvTime dStartDate, LdvTime dEndDate)
	{
		addMandate(tree, "LROOT1", iAngle, iRadius, dStartDate, dEndDate) ;
	}
	
	/**
	 * Adding an administration mandate in a team document tree
	 * 
	 * @param tree <code>LdvModelTree</code> to add information to
	 * @param iAngle angle in the rose 
	 * @param iRadius radius in the rose
	 * @param dStartDate mandate starting date
	 * @param dEndDate mandate ending date
	 * @return void
	 * 
	 **/
	public void addAccessMandate(LdvModelTree tree, int iAngle, int iRadius, LdvTime dStartDate, LdvTime dEndDate)
	{
		addMandate(tree, "LMAND1", iAngle, iRadius, dStartDate, dEndDate) ;
	}
	
	/**
	 * Add a mandate in a team document tree 
	 * 
	 * @param tree <code>LdvModelTree</code> to add information to
	 * @param sType root node of the mandate sub-tree; <code>LROOT1</code> for administration mandate, <code>LMAND1</code> for access mandate
	 * @param iAngle angle in the rose 
	 * @param iRadius radius in the rose
	 * @param dStartDate mandate starting date
	 * @param dEndDate mandate ending date
	 * @return void
	 * 
	 **/
	public void addMandate(LdvModelTree tree, String sType, int iAngle, int iRadius, LdvTime dStartDate, LdvTime dEndDate)
	{
		if ((null == tree) || (null == sType) || sType.equals("") || (null == dStartDate) || dStartDate.isEmpty() || (null == dEndDate) || dEndDate.isEmpty())
			return ;
		
		// Type
		//
		tree.addNode(new LdvModelNode(sType), 2) ;
		
		// Position inside the rose
		//
		Integer intRadius = iRadius ;
		Integer intAngle  = iAngle ;
		tree.addNode(new LdvModelNode("LPOSI1"), 3) ;
		tree.addNode(new LdvModelNode("VANPA1"), 4) ;
		tree.addNode(new LdvModelNode("£N0;02", intAngle.toString(), "2RODE1"), 5) ;
		tree.addNode(new LdvModelNode("VDIPA1"), 4) ;
		tree.addNode(new LdvModelNode("£N0;02", intRadius.toString(), "200001"), 5) ;
		
		// Dates
		//
		tree.addNode(new LdvModelNode("KOUVR1"), 3) ;
		tree.addNode(new LdvModelNode("£T0;19", dStartDate.getDateTime(), "2DA021"), 4) ;
		tree.addNode(new LdvModelNode("KFERM1"), 3) ;
		tree.addNode(new LdvModelNode("£T0;19", dEndDate.getDateTime(), "2DA021"), 4) ;
	}
	
	/**
	 * Create a folders library document 
	 * 
	 * @param sProjectDocumentId project's root document Id
	 * @param timeNow creation time
	 * @return folders library document's Id
	 * 
	 **/
	public String createProjectFoldersLibrary(String sProjectDocumentId, LdvTime timeNow)
	{
		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return "" ;
		String sLabelTreeId = _sMaxTreeId ;
	
		// Create team document's label 
		//
		DocumentLabel LabelDoc = new DocumentLabel(sLabelTreeId, LdvGraphConfig.SYSTEM_USER, "ZCS001", "folders library", "0LIBC1", timeNow) ;
		LdvXmlDocument Label = new LdvXmlDocument(this, LabelDoc) ;
		_aTrees.add(Label) ;

		// Get a new tree Id, and store it (before it changes)
		//
		if (false == getNexTreeId())
			return "" ;
		String sDocTreeId = _sMaxTreeId ;
	
		// Create team document's data 
		//
		LdvXmlDocument Document = new LdvXmlDocument(this, sDocTreeId, "0LIBC1") ;
		_aTrees.add(Document) ;
	
		// Link label and document
		//
		addNewLink(sLabelTreeId, "ZDATA", sDocTreeId, "") ;
	
		// Link team label and root label
		//
		addNewLink(sProjectDocumentId, "0LIBC", sLabelTreeId, "") ;
		
		return sLabelTreeId ;
	}
	
	public int getServerType()
  {
  	return _iServerType ;
  }
	public void setServerType(int iServerType)
  {
  	_iServerType = iServerType ;
  }

	public String getPersonId()
  {
  	return _sPersonId ;
  }
	public void setPersonId(String sPersonId)
  {
  	_sPersonId = sPersonId ;
  }

	public String getMaxTreeId()
  {
  	return _sMaxTreeId ;
  }
	public void setMaxTreeId(String sMaxTreeId)
  {
  	_sMaxTreeId = sMaxTreeId ;
  }
	
	public Document getLinks()
  {
  	return _aLinks ;
  }
}
